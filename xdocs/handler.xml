<?xml version="1.0"?>

<document>
  <properties>
    <title>Handlers</title>
    <author email="hannes@helma.at">Hannes Wallnofer</author>
  </properties>

  <body>
    <section name="Handlers">
      <p>
      </p>
    </section>
  </body>
</document>

<!--

The classes <a href="/static/apidocs/helma/xmlrpc/XmlRpcServer.html">
helma.xmlrpc.XmlRpcServer</a> and <a href="/static/apidocs/helma/xmlrpc/WebServer.html">
helma.xmlrpc.WebServer</a> provide two methods that let your register and 
unregister Java objects as XML-RPC handlers:

<tt>addHandler (String name, Object handler);</tt>
<tt>removeHandler (String name);</tt>

Depending on what kind of handler object you give to the server, it will do 
one of the following things:

<ol>
  <li> 
    If you pass the XmlRpcServer any Java object, the server will 
    try to look up the corresponding method by looking at the method name and 
    the parameter types of incoming requests. The input parameters of incoming 
    XML-RPC requests must match the argument types of the Java method 
    (see <a href="/docs/types/">conversion table</a>), or otherwise the method 
    won't be found. The return value of the Java method must be supported 
    by XML-RPC.
  </li>

  <li>
    If you pass the XmlRpcServer an object that implements interface 
    <a href="/static/apidocs/helma/xmlrpc/XmlRpcHandler.html">
    helma.xmlrpc.XmlRpcHandler</a> or 
    <a href="/static/apidocs/helma/xmlrpc/AuthenticatedXmlRpcHandler.html">
    helma.xmlrpc.AuthenticatedXmlRpcHandler</a> you'll be in full control 
    of how the XML-RPC request is processed, including input and output 
    parameter conversion, special error handling etc. Note that the XmlRpcClient 
    in this library also implements XmlRpcHandler, so it can act as an XML-RPC 
    proxy. This is very useful for applets that can only connect to the server 
    they came from. <a href="http://helma.at/hannes/xmlrpc_test.html">
    (Click here for a demo.)</a>
  </li>
</ol>

In both cases, incoming requests will be interpreted as 
<tt>handlerName.methodName</tt> with <tt>handlerName</tt> being the String 
that the handler has been registered with, and <tt>methodName</tt> being the 
name of the method to be invoked. You can work around this scheme by 
registering a handler with the name "$default", in which case you can 
drop the <tt>handlerName.</tt> part from the method name.

-->
