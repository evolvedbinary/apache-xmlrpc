<faqs title="FAQ">
  <part id="client">
    <faq id="compression_request">
      <question>How do I enable request compression?</question>
      <answer>
        <p>That's simple: Set the properties "enabledForExtensions"
          and "gzipCompressing". That said, note the following
          hints:</p>
        <ul>
          <li>Setting these properties will only work, if the XML-RPC
            server is aware of request compression. Compression is a
            violation of the XML-RPC specification, so typically the
            server will refuse the request, unless it is an Apache
            XML-RPC server with version 2 or later. (Apache XML-RPC 2
            supports request compression, although it was officially
            designed to be strictly compliant to the XML-RPC specification.
            However, noone was aware, that compression violates the
            specification. :-)</li>
          <li>Compressing the request doesn't mean that the response
            will also be compressed. You need to request response
            compression to achieve that.</li>
          <li>Additionally, be aware of the following: Compression
            depends on HTTP/1.1 features. In particular, you must
            not use the LiteHttpTransport.</li>
        </ul>
      </answer>
    </faq>

    <faq id="compression_response">
      <question>How do I enable response compression?</question>
      <answer>
        <p>That's as simple as enabling request compression: Set the
          properties "enabledForExtensions" and "gzipRequesting".
          That said, note the following hints:</p>
        <ul>
          <li>Requesting gzip compression is a standard HTTP feature.
            In other words, you may safely request compression from
            any XML-RPC server, even if it doesn't run Apache XML-RPC.
            </li>
          <li>However, requesting compression doesn't necessarily mean,
            that the response *is* compressed. It depends on the server.</li>
          <li>Additionally, be aware of the following: Compression
            depends on HTTP/1.1 features. In particular, you must
            not use the LiteHttpTransport.</li>
        </ul>
      </answer>
    </faq>

    <faq id="timeout_callback">
      <question>Is it possible to specify a timeout, after which the
        client stops waiting for the servers response?</question>
      <answer>
        <p>Yes, use the class TimingOutCallback.</p>
        <source><![CDATA[
    // Wait for 10 seconds.
    TimingOutCallback callback = new TimingOutCallback(10 * 1000);
    XmlRpcClient client = new XmlRpcClient(url);
    client.executeAsync(methodName, params, callback);
    try {
        return callback.waitForResponse();
    } catch (TimeoutException e) {
        System.out.println("No response from server.");
    } catch (Exception e) {
        System.out.println("Server returned an error message.");
    }
        ]]></source>
      </answer>
    </faq>

    <faq id="nonstandard_date_format">
      <question>I've got a server, which is expecting a non-standard
        date format. How can I ensure, that my date values have the
        right format?</question>
      <answer>
        <p>You've got to use a special type factory. An example is
          contained in the documentation on
          {{{advanced.html}advanced topics}}.</p>
      </answer>
    </faq>
  </part>

  <part id="server">
    <faq id="streaming_mode">
      <question>How do I enable streaming mode?</question>
      <answer>
        <p>Set the property "enabledForExtensions". Note, that enabling
          the streaming mode doesn't mean, that all responses are served
          in streaming mode. It depends on the clients:</p>
        <ul>
          <li>If a client sends a content-length header, then the server
            assumes, that the client is a traditional XML-RPC application
            and doesn't support the vendor extensions from Apache XML-RPC.
            Consequently, the server assumes, that it needs to set the
            content-length header itself and disables the streaming mode
            for that particular request.</li>
          <li>However, if the client doesn't send a content-length header,
            then the server assumes that it will be able to accept any
            standard HTTP/1.1 request and enable the streaming mode.
            Streaming mode means, in particular, that the response will
            not contain a content-length header.</li>
        </ul>
      </answer>
    </faq>

    <faq id="basic_authentication">
      <question>How do I configure the server for basic authentication?</question>
      <answer>
        <p>Basically you've got to provide an AuthenticationHandler.
          See the {{{server.html}server documentation}} for an example.</p>
      </answer>
    </faq>

    <faq id="handler_initialization">
      <question>How do I initalize the request processors?</question>
      <answer>
        <p>The PropertyHandlerMapping assumes, that request processors are
          POJO's (plain old java objects). However, this is not always
          desirable. For example, sometimes it is assumed that handlers
          need to be initialized by the servlet, which is configured through
          parameters.</p>
        <p>The recommended solution is to configure your server with a
          special request processor factory.</p>
<source>
public interface InitializableRequestProcessor {
    void init(HttpServlet pServlet) throws XmlRpcException;
}

public class MyXmlRpcServlet extends XmlRpcServlet {
    protected PropertyHandlerMapping newPropertyHandlerMapping(URL url) throws IOException, XmlRpcException {
        PropertyHandlerMapping mapping = super.newPropertyHandlerMapping(url);
	    RequestProcessorFactoryFactory factory = new RequestSpecificProcessorFactoryFactory(){
	        protected Object newRequestProcessor(Class pClass, XmlRpcRequest pRequest) {
	            InitializableRequestProcessor proc = super.newRequestProcessor(pClass, pRequest);
	            proc.init(MyXmlRpcServlet.this);
	            return proc;
	        }
	    };
	    mapping.setRequestProcessorFactoryFactory(mapping);
	    return mapping;
	}
    
}
</source>
      </answer>
    </faq>

    <faq id="client_ip">
      <question>How to I get the clients IP address in a handler?</question>
      <answer>
        <p>That's a similar question than the question on initializing handlers.
          The main difference is, that in this case you want to initialize the
          handler with any request. So, here's how to do it: First of all,
          we assume that all handlers will implement an interface
          RequestInitializableHandler. This interface has an init method,
          which is being called to receive an object with the clients
          IP address:</p>
        <source><![CDATA[
public class MyConfig extends XmlRpcHttpRequestConfigImpl {
	private String clientIpAddress;
	public String getClientIpAddress() {
	    return clientIpAddress;
	}
	public void setClientIpAddress(String pClientIpAddress) {
	    clientIpAddress = pClientIpAddress;
	}
}

public interface RequestInitializableRequestProcessor {
    public void init(MyConfig pConfig);
}

public class MyXmlRpcServlet extends XmlRpcServlet {
	protected XmlRpcServletServer newXmlRpcServer(ServletConfig pConfig)
			throws XmlRpcException {
		return new XmlRpcServletServer(){
	        protected XmlRpcHttpRequestConfigImpl newConfig(HttpServletRequest pRequest) {
	            MyConfig config = new MyConfig();
	            config.setClientIpAddress(pRequest.getRemoteAddr());
	            return config;
	        }
		};
	}
	protected PropertyHandlerMapping newPropertyHandlerMapping(URL url) throws IOException, XmlRpcException {
        PropertyHandlerMapping mapping = super.newPropertyHandlerMapping(url);
	    RequestProcessorFactoryFactory factory = new RequestSpecificProcessorFactoryFactory(){
	        protected Object newRequestProcessor(Class pClass, XmlRpcRequest pRequest) {
	            RequestInitializableRequestProcessor proc =
	                (RequestInitializableRequestProcessor) super.newRequestProcessor(pClass, pRequest);
	            proc.init(pRequest.getConfig());
	            return proc;
	        }
	    };
	    mapping.setRequestProcessorFactoryFactory(mapping);
	    return mapping;
	}
}
        ]]></source>
      </answer>
    </faq>

    <faq id="client_ip_webserver">
      <question>How to I get the clients IP address in a handler when using the WebServer class?</question>
      <answer>
        Use the ServletWebServer class and see the answer to the previous question.
      </answer>
    </faq>
  </part>
</faqs>
